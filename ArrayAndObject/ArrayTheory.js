//Array theory
/*
у массивов существуют различные методы позволяющие быстро с ними взаимодействовать 
основнымия вляются методы по добавлению и удалению элементов массива
1)
push - добавляет элемент в конец массива
shift - добав элем в нач массива

pop - ИЗВЛЕКАЕТ элем в конце массива
unshift - ИЗВЛЕКАЕТ элемент в нач массива

перебрать элементы массива можно или с пом цикла
for(..;..;..)
или более современным 
for (let item of array)
2)
мы можем отобразить в обратном порядке наш массив используя
reverse()
console.log(names.reverse())
при этом создается новый массив мутирующий из старого
есть новый метод не мутирующий сущ массив а записывающий новый на основе старого и это toReversed
3)
если нам нужно отсортировать массив можно использовать метод sort. Метод может принимать в себя функцию в которой задается условие сортировки
есть новый метод не мутирующий сущ массив а записывающий новый на основе старого и это toSorted
4)
если нам нужно удалить определенное количество элементов в массиве начиная с определенного места используем метод splice. Он принимает индекс элемента, колличество удаляемых эллементов и выводит эти элементы как другой массив
есть новый метод не мутирующий сущ массив а записывающий новый на основе старого и это toSpliced
5)
если нам нужно найти индекс известного элемента массива можно использовать метод indexOf
есть новый метод не мутирующий сущ массив а записывающий новый на основе старого и это with
6)
!!! map
очень важный и часто использ метод. Позволяет нам применить анонимную функцию ко всем эллементам массива и создает новый массив. Функция в map своим элементом принимает элемент самого массива а в теле функции выполняется взаимодействие с каждым эл массива
7)
если нам нужно узнать есть ли нужный нам элемент в массиве используем метод еincludes. если указанный элемент есть возвращ true иначе false

*/

const names = ['Владилен', 'Елен', 'Игорь', 'Ксения'];
names.push('Alena'); // добавили довый элемент в конец массива
names.unshift('Alex'); // добавили элемент в начало работает медленно тк переписывает length и сдвигает индекс у всех эллементов в массиве
// извлекаем элемент names.shift();, но не удаляем его он остается доступен
const MyName = names.shift(); //['Владилен', 'Елен', 'Игорь', 'Ксения', 'Alena'] Alex - из массива извлекли но в памяти осталось и можем вывести Alex
//1)
console.log('Имена:', names, MyName); // вывели результат, массив
//2)
console.log(names.reverse()); // было ['Владилен', 'Елен', 'Игорь', 'Ксения']; стало ['Alena', 'Ксения', 'Игорь', 'Елен', 'Владилен'] не учитываем что добавляли/удаляли элементы важен сейчас их порядок
//3)
const MyNum = [1, 3, 2, 5, 4]; //[1, 2, 3, 4, 5]
console.log(MyNum.sort());
//4)
console.log(names.splice(2, 1)); // ['Игорь']
console.log(names); //['Alena', 'Ксения', 'Елен', 'Владилен']
//5)
const MyFriend = 'Владилен';
console.log(names.indexOf(MyFriend)); //['Alena', 'Ксения', 'Елен', 'Владилен'] будет 3
const index = names.indexOf(MyFriend);
console.log(names[index]); // обращаемся к names по index. выведет нам имя Владилен
//можем изменить значение в массиве для данного элемента
names[index] = 'Владилен JS';
console.log(names); //['Alena', 'Ксения', 'Елен', 'Владилен JS']
//6)
names.map(function (name) {
  console.log((newName = name + '!!!')); // обязательно нужно возвращать что-то в функции в против случае JS вернёт undefined
  return newName;
});
//7)
console.log(names.includes('Елен')); // true
//тоже можно сделать с помощью indexOf сравнив результат с не равно -1 т.к. этот метод возвращ -1 при отсут заданного элемента:
console.log(names.indexOf('Елен') !== -1); // true

// Объекты внутри массива
/*При работе с объектами  в массиве не получится использовать еincludes или indexOf. Можно сделать это алгоритмом:
let findedPerson
for (let person of people) {
    if (person.budget === 12000){
        findedPerson = person
    }
}
но лучше делать это с пом спец методов:
1)find - чтобы найти элемент
2)findIndex - чтобы найти индекс элемента
3)filter - помогает отфильтровать и найти соответ условию элемент массива
*/
const people = [
  { name: 'Владилен', budget: 12000 },
  { name: 'Елен', budget: 1234 },
  { name: 'Игорь', budget: 1000 },
  { name: 'Ксения', budget: 6200 },
];

//1)
const findedPerson = people.find(function (person) {
  //обращаемся к элементам объекта
  /*
  if (person.budget === 12000) {
    return true; // обязательно возвращ булев значение
  }
  */
  //можно упростить и не исп if
  return person.budget === 12000; //true
});
console.log(findedPerson); //{name: 'Владилен', budget: 12000}

//2)
const indPerson = people.findIndex(function (person) {
  return person.budget === 12000; //true
});
console.log(indPerson); // 0

//3)
const filtered = people.filter(function (p) {
  // все эти р и person задаем сами произвольно как хотим так и называем
  return p.budget > 10000;
});
console.log(filtered); // 0:{name: 'Владилен', budget: 12000} length:1 и тд

//Пример задачи, нужно посчитать бюджет всех людей у которых он соответ определ критерию

//1-й вариант//
let sumBudget = 0;
const filtBudget = people.filter(function (p) {
  return p.budget > 1000; // здесь мы фильтруем все элементы массива people где каждый элемент р соответ требованию p.budget > 1000
});
filtBudget.forEach(function (p) {
  sumBudget += p.budget; //далее используя метод forEach мы суммируем каждый найденный ранее элемент и возвращаем сумму
});
console.log(sumBudget); //19434

//2-й вариант//
// можно используя стрелочные функции преобразить код

const sumBud = people // наш массив объектов
  .filter((p) => p.budget > 1000) //фильтруем каждый элемент в соответ с условием, стрелоч функ использ без return тк JS автоматом уже подстав его в ней. Т.к filter возвращ нам массив мы можем вызвать у него ещё один метод наприм map и трансформируем массив
  .map((p) => p.budget) // далее берем все отфильтрованные элементы массива и возвращаем из него все числа а именно p.budget
  .reduce((acc, p) => acc + p, 0); // возвращает нам одно результирующее значение для работы требуется accumulator это (acc) где аккум значение и currentValue это (р) передать в функцию 0 указываем для точки отсчета(начальное значение)
console.log(sumBud); //19434

// Работа со строкой как массивом элементов//
//1) метод split превращает строку в массив. В него мы должны передать по какому признаку хотим разделить строку на элементы, если ("" - пусто) мы разделим строку на отдельные элементы

// Задание нам нужно развернуть слова в строке
//1)
const string = 'Hellow how are you?';
const Reversed = string.split('').toReversed().join(''); //мы разбили нашу строку 'Hellow how are you?' на отдел элементы. Далее развернули эти элементы в обратном порядке. Дальше соединили эти элементы и преобразовали в новую строку(join('') можно использ различные разделители если передать '' получим без них, по умолчанию если () будет ,)
console.log(Reversed); //?uoy era woh wolleH
