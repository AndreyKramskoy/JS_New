const person = {
  name: 'Vladilen',
  age: 29,
  isYoutuber: true,
  languages: ['ru', 'en'],
  address: {
    city: 'Saint-Petersburg',
    street: 'Nesvky',
  },
  //можно создавать комплексные ключи состоящие из нескольких слов для этого нужно исп ковычки 'complex key':. так же и с комплексными значениями
  'complex key': 'complex value',
  ['key_' + 21 * 2]: 'computed value', // мы можем использовать вычисляемые ключи и для этого их нужно заключать в квадрат скобки ['key_' + 21 * 2]:
  greet() {
    console.log('Greet from person', this); //внутри объекта могут создаваться функции greet() {
  },
  arrow: () => {
    console.log('Person Arrow', this); // внутри объекта можно создавать стрел функ как arrow: () => {
  },
  info() {
    console.log('Person name', this.name);
    // !!! Когда мы ображаемся к this функции находящ внутри Объекта, считается что мы обращаемся ко всему этому объекту, а далее мы можем пойти по ключам этого объекта как в примерах выше
  },
};
//Примеры работы с элементами объекта вывод изменения удаление
// console.log(person.address);
// const addressKey = 'address';
// console.log(person[addressKey]);
// console.log(person['complex key']);
// person.age++;
// person.languages.push('de');
// console.log(person.languages);
// person.address = undefined;
// delete person.address;
// console.log(person);

// мы можем получать значения по ключам из объекта перечисляя их связь через объект.ключ как приведено ниже
// Destructoring
// const age = person.age
// const name = person.name
// const languages = person.languages
//Но это не совсем верно и красиво, тк у нас много повторение и очень громозко все. Поэтому можно использовать Деструкторизацию объекта как в примере ниже. Мы созд константу и в фигур скобках указываем ключи объекта===названию наших переменных и присваиваем это нашему объекту
const { age, name: firstName = 'TEST', languages } = person;
console.log(languages, age, firstName);

//Для итерации объекта используем цикл for (let key in object)
for (let key in person) {
  if (person.hasOwnProperty(key)) {
    // данной строкой мы добавили проверку на работу только с собственными ключами воизбежания ошибки при работе кода. тк в языки сущ прототипирование и при определ условиях код может пытаться взаимодейст с ключами прототипа объекта
    console.log(person[key]);
  }
}
//!!! это уже современный способ взаимодействовать с объектом избегая доп проверок прототипирования!!!
// Object.keys(person).forEach((key) => {
// Object.keys(person) возвращ массив объекта с которым работатет .forEach((key)и возвращает в консоль значения ключей нашего объекта
//   console.log(person[key])
// })

const logger = {
  keys(withText = true) {
    if (withText) {
      console.log('Object keys:', Object.keys(this));
    } else {
      console.log(Object.keys(this));
    }
  },

  keysAndValues() {
    Object.keys(this).forEach((key) => {
      console.log('Key:', key);
      console.log('Value:', this[key]);
    });
  },
};

// const bound = logger.keys.bind(person)
// bound(false)
// logger.keys.call(person, false)
// logger.keys.apply(person, [false])
/*
1. call:
Синтаксис: function.call(thisArg, arg1, arg2, ...).
Вызывает функцию, указанную как метод объекта (thisArg), передавая ей аргументы в виде списка.
Первый аргумент (thisArg) определяет, на каком объекте будет выполнена функция.
2. apply:
Синтаксис: function.apply(thisArg, [argsArray]).
Работает аналогично методу call, но аргументы передаются в виде массива
3. bind:
Синтаксис: function.bind(thisArg, arg1, arg2, ...).
Создаёт новую функцию, привязывая указанный объект (thisArg) к её контексту выполнения. Эта новая функция будет иметь предопределённые аргументы, которые можно передать в момент вызова.
Не вызывает функцию немедленно, а возвращает новую функцию, которую можно вызвать позже.
Итак, основное отличие между ними:

call и apply вызывают функцию немедленно и передают аргументы.
bind создаёт новую функцию с привязанным контекстом, но не вызывает её немедленно.
*/

class Human {
  // прототипом данного класса уже будет глобальный класс Object
  // наследование. это базовый клаас от которого наследуется класс Person для этого используется extends Human в наследуемом классе и чтобы вызвать конструктор базового класса в наследуемом и проинициализоровать его используется функция  super();
  static isHuman = true; // внизу ифа по static

  humanGreet() {
    console.log('greet from human');
  }

  toString() {
    console.log('to string');
  }
}

class Person extends Human {
  //прототипом данного класса Person будет родительский класс Human
  //классы позволяю создавать объекты
  constructor(name, age) {
    // через метод constructor связываем наш const person1 = new Person('Vladilen', 30); с классом Person
    super(); // вызывает родительский конструктор (класс Human)
    this.name = name ?? 'Undefined name'; //через this.name мы получаем доступ к объекту например const person1 = где забираем через new Person('Vladilen', 30); соответ значения ключей
    this.age = age ?? 'Undefined age'; // ?? используем для определения ЕСЛИ который определ налич значений и передает второе если первого не передали
  }

  sayHello() {
    //в классах можно создавать методы
    console.log('Hello from ', this.name); // метод будет работать с передаваемыми классу ключами объектов и выводить в данном случае 'Hello from Vladilen' например
  }
}

const person1 = new Person('Vladilen', 30); //создали объект относящийся к классу Person и при инициализации мы добавляем указанные знач в наш объект класса Person расписанный выше, для работы этой связи использ специальный метод  constructor(name, age) { он вызывается в нашем классе когда выполняем new Person('Vladilen', 30)
const person2 = new Person('Elena', 21); //!!! те благодаря классу мы можем один раз описать структуру и далее переиспольз класс для создания новых объектов на основе получаемых данных как здесь new Person('Elena', 21)

// console.log(Person.isHuman)
/*
Прототипирование - это ключевая концепция в языке программирования JavaScript. Она относится к тому, как объекты наследуют свойства и методы других объектов. В JavaScript все объекты имеют свойство prototype, которое может быть использовано для создания иерархии наследования между объектами.
Вот как это работает подробнее:
Прототипы и объекты:
Каждый объект в JavaScript имеет свойство __proto__, которое указывает на прототип объекта. Прототип - это другой объект, который предоставляет свойства и методы для наследования. Прототип объекта может быть либо другим объектом, либо значением null.
Создание объектов:
Для создания объекта можно использовать литерал объекта {} или конструктор объекта, например new Object(). Все созданные объекты имеют встроенное свойство __proto__, которое ссылается на прототип объекта.
Прототипы функций:
Каждая функция также имеет свойство prototype, которое используется при создании новых объектов через эту функцию в качестве конструктора. По умолчанию свойство prototype функции содержит только одно свойство - constructor, указывающее на саму функцию.
Наследование:
Когда вы обращаетесь к свойству или методу объекта, которого нет в этом объекте, JavaScript ищет это свойство или метод в прототипе (и, если необходимо, в цепочке прототипов). Это называется цепочкой прототипов.
Использование Object.create():
Метод Object.create(proto) позволяет создать новый объект с заданным прототипом. Это более гибкий способ создания объектов с определенной иерархией наследования.
*/

/*В JavaScript, ключевое слово static используется в контексте классов и объектов, чтобы определить статические свойства и методы. Статические свойства и методы принадлежат самому классу, а не его экземплярам. Это означает, что они вызываются и используются напрямую на самом классе, а не на объектах, созданных из этого класса.

Пример использования статических свойств и методов:
Статические методы для вспомогательных функций: Если у вас есть функции, которые связаны с классом, но не зависят от конкретных экземпляров, их можно определить как статические методы. Пример: Math.random().
Подсчёт количества экземпляров класса: Вы можете использовать статическое свойство для отслеживания количества созданных экземпляров класса.
Создание синглтонов: Статический метод и свойство могут быть использованы для создания синглтона — класса, который имеет только один экземпляр.
Фабричные методы: Статические методы могут использоваться для создания объектов, как фабричные методы.
Важно помнить, что статические методы и свойства недоступны на экземплярах класса, они принадлежат самому классу.
*/
